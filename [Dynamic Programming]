[Dynamic Programming]
-> using fibonachi sequence

1. Recursion
	def fib(n):
		if n == 1 or n ==2:
			result = 1
		else:
			result = fib(n-1) + fib(n-2)
		return result

	-> very inefficient. because of too many calculations

2. Store (Memoize)
	- need n+1 array <- store return value rather than computation

	def fib_2(n, memo):    
		if memo[n] is not None:
		return memo[n]
		if n == 1 or n == 2:
			result = 1
		else:
			result = fib(n-1) + fib(n-2)
			memo[n] = result
		return result

	def fib_memo(n):
		memo = [None] * (n+1)
		return fib_2(n, memo)

		# memo is n+1 array that store value
		# and memo needed to be null or 0 before beginning algorithm

3. Bottom-up 
	- similar with Memoize
	- very fast

def fib_bottom_up(n):
	if n == 1 or n == 2:
		return 1
	bottom_up = [None] * (n+1)
	bottom_up[1] = 1
	bottom_up[2] = 1
	for i in range(3, n+1):
		bottom_up[i] = bottom_up[i-1] + bottom_up[i-2]
	return bottom_up[n]



- 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어. (동적할당에서의 다이나믹과 다름)


- 다이나믹 프로그래밍은 다음의 조건을 만족할 때 사용
	1. 최적부분 구조(Optimal Substructure)
		: 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있을때.
	
	2. 중복되는 부분 문제(Overlapping Subproblem)
		: 동일한 작은 문제를 반복적으로 해결할 

- 다이나믹 프로그래밍은 점화식으로 구해서 풀면 간단.


- 재귀적인 방법을 쓰면 연산 수가 너무 많아진다.


- 다이나믹 프로그래밍에서 사용되는 방식은 두가지로,
	1. Memoization(Top-down) 방식
		- 힌번 계산된 결과를 메모리 공간에 메모
			- 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴
			- 값을 기록해 놓는다는 점에서 cashing이라고도 함.
		- 엄밀히 말하면 memoization은 이전에 계산된 결과를 일시적으로 기록해 놓는 것을 칭하는 넓은 의미.
			-> 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님.
			-> 한번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있음.

		[ex] N번째 피보나치 수열 구하기 - 재귀함수 사용
		N = 99
		d = [0] * N+1

		def fibo(x):
			if x == 1 or x == 2:
				return 1
			if d[x] != 0:
				return d[x]
			else:
				d[x] = fibo(x-1) + fibo(x-2)
			return d[x]

		print(fibo(N))
	
	2. Bottom-up 방식 - 반복문 사용
		- 밑에서부터 차례데로 해결.(반복문 사용)
		- 결과 저장용 리스트는 DP테이블이라고 부름.

		[ex] - 반복문 사용
		N = 99
		d = [0] * N+1

		d[1] = 1
		d[2] = 1

		for i in range(3, N+1):
			d[i] = d[i-1] + d[i-2]

		print(d[N])


- 다이나믹 프로그래밍 vs 분할정복
	- 다이나믹 프로그래밍과 분할 정복은 모두 최적 부분 구조를 가질 때 사용
		- 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황.
	
	- 다이나믹 프로그래밍과 분할 정복의 차이점은 부분 문제의 중복.
		- 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복.
		- 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않음.


- 다이나믹 프로그래밍 문제에 접근하는 방법
	- 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요.
	
	- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있음.
		- 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려.
	
	- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운 방식) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면,
	코드를 개선하는 방법을 사용할 수 있음.
